//Abiria Placide
//axp1223

//-----------------------------------------------------------------------------
// Hardware Target
//-----------------------------------------------------------------------------

// Target Platform: EK-TM4C123GXL with LCD Interface
// Target uC:       TM4C123GH6PM
// System Clock:    40 MHz

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "tm4c123gh6pm.h"
#include "lab5_AbiriaPlacide.h"
#include "lab6_AbiriaPlacide.h"
#include "uart0.h"


//ALL HASH defines

// PortB masks
#define RED_BL_LED_MASK 32
// PortE masks

#define BLUE_BL_LED_MASK 16
#define GREEN_BL_LED_MASK 32

//LEDS DEBUGGING
#define DEBUG

#define GREEN_LED_MASK 8
#define BLUE_LED_MASK  4
#define RED_LED_MASK  2

#define RED_LED      (*((volatile uint32_t *)(0x42000000 + (0x400253FC-0x40000000)*32 +  1*4)))
#define BLUE_LED      (*((volatile uint32_t *)(0x42000000 + (0x400253FC-0x40000000)*32 + 2*4)))
#define GREEN_LED     (*((volatile uint32_t *)(0x42000000 + (0x400253FC-0x40000000)*32 + 3*4)))

#define LOGICAL_BASE_PULSE  22500  //at 40 Mhz where time  = 526.5 us
#define LOGICAL_1_PULSE_OFF 67500 // at 40 Mhz where time  = 1.6875ms
#define LOGICAL_1_PULSE_ON  LOGICAL_BASE_PULSE
#define LOGICAL_0_PULSE_ON  LOGICAL_BASE_PULSE
#define LOGICAL_0_PULSE_OFF LOGICAL_BASE_PULSE
#define END_TRANSMISSION    LOGICAL_BASE_PULSE
#define NINE_millisec 360000
#define FOUR_FIVE_millisec 180000//4.5 ms

//prototypes
void configure_timer2(uint32_t freq, bool period);
void IRQ_Timer2_ISR();
void load_byte(uint8_t byte);

//global variables

uint8_t Commands[] = {162,98,226,34,2,194,224,168,144,104,152,176,48,24,122,16,56,90,66,74,82}; //Button Data from IR Remote controller
bool pulse_status  = 0; //use to check if pwm on PB 5 is driving IR LED (IE, ON or OFF)
bool nine_ms_ready = 0;
bool four_ms_ready = 0;
bool data_ready = 0; //used to make sure bytes are ready to be sent. In case instructions are being ran in parrallel.
uint8_t byte_index = 0;
uint8_t sampleData[] = {0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,0,1}; //this is a representation of 0


// Initialize PWM0 gen 1 on PB5
void initPWM()
{
    putsUart0("initializing PWM0...\r\n");
    // Configure HW to work with 16 MHz XTAL, PLL enabled, system clock of 40 MHz
    //SYSCTL_RCC_R = SYSCTL_RCC_XTAL_16MHZ | SYSCTL_RCC_OSCSRC_MAIN | SYSCTL_RCC_USESYSDIV | (4 << SYSCTL_RCC_SYSDIV_S);

    // Set GPIO ports to use APB (not needed since default configuration -- for clarity)
    SYSCTL_GPIOHBCTL_R = 0;
    // Enable clocks
    SYSCTL_RCGCPWM_R |= SYSCTL_RCGCPWM_R0;
    SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R1 | SYSCTL_RCGCGPIO_R4 |SYSCTL_RCGCGPIO_R5; //enable clock for PORT B & E & F
    SYSCTL_RCGCTIMER_R |= SYSCTL_RCGCTIMER_R2; //enable clock for timer2
    _delay_cycles(3);

    // Configure three backlight LEDs
    GPIO_PORTB_DIR_R   |= RED_BL_LED_MASK;                       // make bit5 of PORTB a PWM output
    GPIO_PORTB_DR2R_R  |= RED_BL_LED_MASK;                      // set drive strength to 2mA
    GPIO_PORTB_DEN_R   |= RED_BL_LED_MASK;                       // enable digital
    GPIO_PORTB_AFSEL_R |= RED_BL_LED_MASK;                     // select auxilary function
    GPIO_PORTB_PCTL_R  &= GPIO_PCTL_PB5_M;                      // = 0x00F00000 enable PWM
    GPIO_PORTB_PCTL_R  |= GPIO_PCTL_PB5_M0PWM3; //0x00400000

#ifdef DEBUG
    // Configure LED and pushbutton pins
    GPIO_PORTF_DIR_R |= GREEN_LED_MASK | BLUE_LED_MASK | RED_LED_MASK;
    GPIO_PORTF_DEN_R |= GREEN_LED_MASK | BLUE_LED_MASK | RED_LED_MASK;

#endif

    // Configure PWM module 0 to drive RGB backlight
    // RED   on M0PWM3 (PB5), M0PWM1b

    SYSCTL_SRPWM_R = SYSCTL_SRPWM_R0;                // reset PWM0 module
    SYSCTL_SRPWM_R = 0;                              // leave reset state
    PWM0_1_CTL_R = 0;                                // turn-off PWM0 generator 1
    PWM0_2_CTL_R = 0;                                // turn-off PWM0 generator 2
    PWM0_1_GENB_R = PWM_0_GENB_ACTCMPBD_ZERO | PWM_0_GENB_ACTLOAD_ONE;
                                                     // output 3 on PWM0, gen 1b, cmpb
    //PWM0_2_GENA_R = PWM_0_GENA_ACTCMPAD_ZERO | PWM_0_GENA_ACTLOAD_ONE;
                                                     // output 4 on PWM0, gen 2a, cmpa
    //PWM0_2_GENB_R = PWM_0_GENB_ACTCMPBD_ZERO | PWM_0_GENB_ACTLOAD_ONE;
                                                     // output 5 on PWM0, gen 2b, cmpb
    PWM0_1_LOAD_R = 1047;//526                            // set period to 40 MHz sys clock / 2 / 1024 = 19.53125 kHz
    //PWM0_2_LOAD_R = 1024;
    PWM0_INVERT_R = PWM_INVERT_PWM3INV;// | PWM_INVERT_PWM4INV | PWM_INVERT_PWM5INV;
                                                     // invert outputs so duty cycle increases with increasing compare values
    PWM0_1_CMPB_R = 524;                               // red off (0=always low, 1023=always high)
    //PWM0_2_CMPB_R = 0;                               // green off
    //PWM0_2_CMPA_R = 0;                               // blue off

    PWM0_1_CTL_R = PWM_0_CTL_ENABLE;                 // turn-on PWM0 generator 1
    /*PWM0_2_CTL_R = PWM_0_CTL_ENABLE;                 // turn-on PWM0 generator 2 */

    PWM0_ENABLE_R = PWM_ENABLE_PWM3EN; //| PWM_ENABLE_PWM4EN | PWM_ENABLE_PWM5EN;
                                                     // enable outputs

    //initially pw0 output should be zero to allow for first 9ms burst when called from a different function
    GPIO_PORTB_DEN_R   &= ~(RED_BL_LED_MASK);
}

void configure_timer2(uint32_t freq, bool period)
{
    TIMER2_CTL_R &= ~TIMER_CTL_TAEN;                 // turn-off timer before reconfiguring
    TIMER2_CFG_R = TIMER_CFG_32_BIT_TIMER;           // configure as 32-bit timer (A+B)
    if (period == true)
    {
        TIMER2_TAMR_R = TIMER_TAMR_TAMR_PERIOD;          // configure for periodic mode (count down)
    }
    else
    {
        TIMER2_TAMR_R = TIMER_TAMR_TAMR_1_SHOT;          // configure for 1-shot mode(count down)
    }

    TIMER2_TAILR_R = freq;                           // set load value to 40e6 for 1 Hz interrupt rate
    TIMER2_IMR_R = TIMER_IMR_TATOIM;                 // turn-on interrupts
    NVIC_EN0_R |= 1 << (INT_TIMER2A-16);             // turn-on interrupt 39 (TIMER2A)
    TIMER2_CTL_R |= TIMER_CTL_TAEN;                  // turn-on timer
}

void IRQ_Timer2_ISR()
{
    if (byte_index) // pulse on at 9ms
    {
        GPIO_PORTB_DEN_R   &= ~RED_BL_LED_MASK; //turn off pwm0
        putsUart0("\r\n9 ms received\r\n");
        //load 4 ms

        byte_index++;
        nine_ms_ready = 0; //only ran once.
    }
    else if (byte_index == 1)
    {
        configure_timer2(FOUR_FIVE_millisec,0);
    }

    else if(pulse_status == 0) //if interrupt is called and pulse is off
    {
        four_ms_ready = 1;
        GPIO_PORTB_DEN_R   |= RED_BL_LED_MASK;
    }

    TIMER2_ICR_R = TIMER_ICR_TATOCINT;               // clear timer 2 interrupt flag for next signal

}

void load_byte(uint8_t byte)
{
    uint8_t i;
    for(i=8 ;i>0;i--)
    {
        //turn on pwm0. and wait for LOGICAL_BASE_PULSE time = 562.5 us
        GPIO_PORTB_DEN_R   |= RED_BL_LED_MASK;
        configure_timer2(LOGICAL_BASE_PULSE,0); //one shot timer. will turn off pwm0 at interrupt call
        //turn off pwm0

        if(byte & 0x80) //if logical 1 add an additional 1.6875 ms
        {
            //delay for 1.6875ms space
            configure_timer2(LOGICAL_1_PULSE_OFF,0);
        }
        else
        {
            //turn off for 562.5 us space
            configure_timer2(LOGICAL_BASE_PULSE,0);
        }

        byte = byte << 1;
    }
}


void playCommand(uint8_t address, uint8_t data)
{
    //turn on pwm0 then wait for 9ms. turned off at timer 2 interrupt
    pulse_status = 1;
    nine_ms_ready = 1;
    GPIO_PORTB_DEN_R |= RED_BL_LED_MASK;
    //timer interrupt will turn off pwm0
    configure_timer2(NINE_millisec, 0); //(freq, 0) means one-shot. (freq, 1) means periodic.

    if(pulse_status == 0)
    {
        //turn off pwm0 for 4.5ms. already off from previous interrupt
        configure_timer2(FOUR_FIVE_millisec,0);
        putsUart0("\r\n4.5ms sent\r\n");
    }

    /*
    //sent data
    load_byte(address);
    load_byte(~address);
    load_byte(data);
    load_byte(~data);

    //last pulse for end of message
    GPIO_PORTB_DEN_R   |= RED_BL_LED_MASK;
    configure_timer2(END_TRANSMISSION,0);
    */
}

int main()
{
    // Setup UART0 & baud_rate
    initUart0();
    setUart0BaudRate(115200, 40e6);
    //inialize shell interfacem
    initLab6();
    //setup pwm0 on PORTB-5
    initPWM();
    putsUart0("Ready...\r\n");
    putcUart0('#');

    USER_DATA data;
    while(true)
    {
         getsUart0(&data); //get data from  tty interface
         putsUart0("\r\n");
         putcUart0('>');
         putsUart0(data.buffer); //output input data

         // Parse fields
         parseFields(&data);
         //copy command

         if(isCommand(&data, "play", 1))
         {
             putsUart0("\r\n play command initiated,sending signal\r\n");
             playCommand(0x0, 162);
         }

         else if (isCommand(&data, "learn", 1))
         {
             putsUart0("\r\n learn command initiated...\r\n");
         }

         else if(isCommand(&data, "erase", 1))
         {
             putsUart0("\r\n erase command initiated...\r\n");
         }

         else
         {
             putsUart0("\r\n invalid command\r\n");
         }

         putsUart0("#");

/*
         uint8_t i;
         //output metadata about command
         for(i =0; i < data.fieldCount; i++)
         {
             putsUart0("\r\n");
             putsUart0("\r\n");
             putcUart0(data.fieldType[i]);
             putsUart0("\r\n");
             putsUart0(&data.buffer[data.fieldPosition[i]]);
             putsUart0("\r\n");
         }
         putsUart0("#");
*/

    }
}

